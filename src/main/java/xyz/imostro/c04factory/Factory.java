package xyz.imostro.c04factory;

/**
 * 为什么需要学习工厂模式？
 *  在一些简单的对象创建，我们仅仅需要把对象new出来即可，不用过多的工作。但是并不是所有对象都可以这么轻松完成初始化工作的，
 *  例如上一张中的装饰者模式，当需要初始化一个杯饮料的时候常常需要多层包装一个对象来完成初始化，这样如果每次初始化都走一遍这个流程的话，重复代码变多，且容易写错
 *  再例如在创建鸭子对象的时候，我们编译时并不知道需要创建哪个鸭子对象，只有在运行时才能得知，那么我们每次创建的时候都要通过if-else语句来判断。
 *  这样写代码都是不雅的，且容易犯错。
 *
 * 需要做什么？
 *  学习封装对象的创建和初始化，不通过手动new创建对象，而是通过工厂创建
 *
 * 问题一：如何将实例化具体类的代码从应用中抽离，或者封装起来，使它们不会干扰应用的其他部分？
 *
 * 工厂模式：
 *     - 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
 *     - 抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
 *
 *  工厂方法与抽象工厂的区别：
 *      ——————————————————————————————————————————————————————————————————
 *      |                           工厂方法                抽象工厂
 *      ——————————————————————————————————————————————————————————————————
 *      |  实现方式                    继承                    组合
 *      ——————————————————————————————————————————————————————————————————
 *      |  用途                       创建一个产品             创建整个产品家族
 *      ——————————————————————————————————————————————————————————————————
 *
 * 设计原则：要依赖抽象，不要依赖具体类（依赖倒置原则）
 *
 * 依赖倒置的指导（尽量满足即可）：
 *      - 变量不可以持有具体类的引用。（如果使用new，就会持有具体类的引用。你可以改用工厂来避开这样的做法）
 *      - 不要让类派生自具体类（如果派生自具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类））
 *      - 不要覆盖基类中已实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真确适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）
 *
 * 本章要点：
 *      - 所有工厂都是用来封装对象的创建
 *      - 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦
 *      - 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。
 *      - 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。
 *      - 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。
 *      - 工厂方法允许类将实例化延迟到子类进行。
 *      - 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。
 *      - 依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象。
 *      - 工厂是很有威力的技巧，帮助我们针对抽象编程，而不是针对具体编程
 *
 * 注意：
 *  1.  ”实现一个接口“ 泛指”实现某个超类型（可以是类或接口）的某个方法“
 */
public class Factory {
}
